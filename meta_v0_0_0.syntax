## Token

byte:
    "\x"[0-9a-fA-F]{2}

string:
    \"{printable char}\"

integer:
    (-|+)?[0-9]+


identifier:
    [a-zA-Z_][a-zA-Z_0-9]*

wp:
    "\"
    "t"
    " "

nr:
    "\r"
    "\n"

wpnr:
    "\r"
    "\n"
    "\t"
    " "

## Gramma
#  XXXX()   ListMatcher separate by regex in ()
#


BaseType:
    "byte"
    "int32"
    "size_t"


SingleType:    # ex: int32, uint8, abc.efg
    BaseType
    Attribute     # custom type


ArrayType:
    SingleType "[" "]"   # ex: int32[], uint8[], abc.efg[]
    ArrayType  "[" "]"   # ex: int32[][], uint8[][][], abc.efg[][][][][]


Type:
    SingleType      # ex: int32, uint8, abc.efg
    ArrayType       # ex: int32, uint8, 


VarDeclaration:
    Identifier(s,) Type "=" Expr(s,)       # with default value
    Identifier(s,) Type
    Identifier(s,) "=" Expr(s,)            # auto type judgement
    identifier "[" "]" "=" ListExpr             # should be list expr in the same type


TypeDeclaration:
    "type" {identifier} "{" VarDeclaration(s) "}"     # can be anonymous

ListExpr:
    "[" Expr(s,) "]"

Expr:     # something that can return a value
    integer
    Attribute
    FunctionCall                 # should have return value
    "(" Expr ")"                 # derived rules
    ListExpr
    Expr BinaryOperator Expr
    UnaryOperator Expr
    Expr "?" Expr ":" Expr


Attribute:
    identifier(s.)

BinaryOperator:
    "+" "-" "*"  "**" "/" "//"
    BitwiseOperator

LogicOperator:
    "&&" "||" "==" "!="

BitwiseOperator:
    "&" "|" "^" ">>" "<<"

UnaryOperator:
    "!"

Operator:
    BinaryOperator
    UnaryOperator
    LogicOperator

AssignmentOperator:
    "="
    "|="
    "&="
    "^="
    "+="
    "-="
    "*="
    "/="
    "**="

LeftValue:
    Attribute(s,)

RightValue:
    Expr(s,)


Assignment:
    LeftValue AssignmentOperator RightValue


FunctioniDeclaration:
    "func" identifer "(" {VarDeclaration} ")"  Blocks

Blocks:
    "{" {Statement(s)} "}"

FunctionCall:
    Attribute "(" Expr(s,) ")"               #direct function call
    Expr "." FunctionCall


Statement:
    "while" Expr Blocks 
    "for"  ";"  ";" Blocks
    "if" Expr Blocks {("elif" Expr Blocks)(s)} {"else" Blocks}?



Module:
    {VarDeclaration(s)}
    {TypeDeclaration(s)}
    {FunctioniDeclaration(s)}
    {Statement(s)}




